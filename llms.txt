# sql_records: Minimal, Type-Safe SQL Wrapper for Dart 3

## Overview
`sql_records` is a functional, minimal wrapper for SQLite (PowerSync) and PostgreSQL that leverages Dart 3 Records for compile-time parameter type safety and "best-effort" runtime result validation. It prioritized a "declare-what-you-use" strategy, ensuring that SQL and its mapping logic are co-located.

## Key Features
- **Multi-Engine Support**: Separate adapters for SQLite (via PowerSync) or PostgreSQL.
- **Record-Based Parameters**: Use Dart Records to define query parameters, getting compile-time safety at the call site.
- **Schema-Aware Results**: Explicitly define expected result schemas using standard Dart types.
- **SafeRow Access**: Access row data with `get<T>`, `getOptional<T>`, and `parse<T, DB>`, catching schema or type drift immediately.
- **Reactive Queries**: Built-in support for `watch` to receive streams of result sets (PowerSync only).
- **Batch Operations**: Efficient `executeBatch` for bulk mutations.
- **Zero Boilerplate**: No code generation or complex ORM configuration required.

## Installation
The library depends on `powersync`, `sqlite3`, `sqlite_async`, and `postgres`.

## Core Concepts

### 1. Defining Queries and Commands
Queries and Commands encapsulate the SQL, the parameter mapping, and a "result token".

#### `Query<P, R>` (Reads)
- **P**: The parameter Record type (e.g., `({String status})`).
- **R**: The expected result Record type (e.g., `({String name, int age})`).
- **schema**: A `Map<String, Type>` defining the expected types of columns.
- **params**: A mapper function or a map literal.

```dart
final activeUsersQuery = Query<({String status}), ({String name, int age})>(
  'SELECT name, age FROM users WHERE status = @status',
  params: (p) => {'status': p.status},
  schema: {'name': String, 'age': int},
);
```

#### `Command<P>` (Mutations)
Used for `INSERT`, `UPDATE`, and `DELETE`.

#### Dynamic Commands (Patching)
- **`UpdateCommand<P>`**: Generates an `UPDATE` statement, skipping any `null` values.
- **`InsertCommand<P>`**: Generates an `INSERT` statement using only non-null values.
- **`SQL(value)`**: A wrapper to distinguish between "omit this field" (plain `null`) and "set this field to NULL" (`SQL(null)`).

### 2. Initialization

#### SQLite / PowerSync
```dart
import 'package:sql_records/powersync_records.dart';
final db = SqlRecordsPowerSync(powersyncDb);
```

#### PostgreSQL
```dart
import 'package:sql_records/postgres_records.dart';
final db = SqlRecordsPostgres(postgresSession);
```

### 3. Executing Queries

#### `getAll`, `get`, `getOptional`
Returns `SafeResultSet<R>` or `SafeRow<R>`.

```dart
final rows = await db.getAll(activeUsersQuery, (status: 'active'));
for (final row in rows) {
  final name = row.get<String>('name');
}
```

### 4. Executing Mutations

#### `execute`
Executes a command and returns a `MutationResult`.

```dart
final result = await db.execute(updateUserCommand, (id: '123', name: 'New Name'));
print('Rows affected: ${result.affectedRows}');
```

#### `executeBatch`
Efficiently executes a command multiple times.

### 5. Transactions

- `readTransaction`: Provides `SqlRecordsReadonly` context.
- `writeTransaction`: Provides `SqlRecords` context.

### 6. SafeRow & Data Parsing
`SafeRow` wraps the raw database row and enforces the schema.

- `row.get<T>(key)`: Type-safe, non-nullable access.
- `row.getOptional<T>(key)`: Type-safe, nullable access.
- `row.parse<T, DB>(key, parser)`: Custom parsing logic.

## Caveats & Troubleshooting
- **Named Parameters**: Use the `@name` syntax.
- **Postgres ID**: `MutationResult.lastInsertId` is always `null` for Postgres unless using `RETURNING` clauses in the query.
- **Watch**: `watch()` is currently only supported for PowerSync.
