# sql_records: Minimal, Type-Safe SQL Wrapper for Dart 3

## Overview
`sql_records` is a functional, minimal wrapper for SQLite (PowerSync or `sqlite3`) and PostgreSQL that leverages Dart 3 Records for compile-time parameter type safety and "best-effort" runtime result validation.

## Key Features
- **Multi-Engine Support**: Separate adapters for SQLite (via PowerSync or `sqlite3`) or PostgreSQL.
- **Record-Based Parameters**: Use Dart Records to define query parameters, getting compile-time safety at the call site.
- **Schema-Aware Results**: Explicitly define expected result schemas using standard Dart types.
- **Row Access**: Access row data with `get<T>`, `getOptional<T>`, and `parse<T, DB>`, catching schema or type drift immediately.
- **Reactive Queries**: Built-in support for `watch` to receive streams of result sets (PowerSync only).
- **Batch Operations**: Efficient `executeBatch` for bulk mutations.
- **Zero Boilerplate**: No code generation or complex ORM configuration required.

## Installation
The library depends on `powersync`, `sqlite3`, `sqlite_async`, and `postgres`.

## Core Concepts

### 1. Defining Queries and Commands
Queries and Commands encapsulate the SQL, the parameter mapping, and a "result token".

#### `Query<P, R>` (Reads)
- **P**: The parameter Record type (e.g., `({String status})`).
- **R**: The expected result Record type (e.g., `({String name, int age})`).
- **schema**: A `Map<String, Type>` defining the expected types of columns.
- **params**: A mapper function or a map literal.

```dart
final activeUsersQuery = Query<({String status}), ({String name, int age})>(
  'SELECT name, age FROM users WHERE status = @status',
  params: (p) => {'status': p.status},
  schema: {'name': String, 'age': int},
);

// Parameterless query
final allUsersQuery = Query<void, ({String name, int age})>.static(
  'SELECT name, age FROM users',
  schema: {'name': String, 'age': int},
);
```

#### `Command<P>` (Mutations)
Used for `INSERT`, `UPDATE`, and `DELETE`.

```dart
final updateAgeCommand = Command<({int id, int age})>(
  'UPDATE users SET age = @age WHERE id = @id',
  params: (p) => {'id': p.id, 'age': p.age},
);

// Parameterless command
final deleteAllCommand = Command.static('DELETE FROM users');
```

#### Dynamic Commands (Patching)
- **`UpdateCommand<P>`**: Generates an `UPDATE` statement, skipping any `null` values.
- **`InsertCommand<P>`**: Generates an `INSERT` statement using only non-null values.
- **`SQL(value)`**: A wrapper to distinguish between "omit this field" (plain `null`) and "set this field to NULL" (`SQL(null)`).

### 2. Initialization

#### SQLite / PowerSync
```dart
import 'package:sql_records/powersync.dart';
final db = SqlRecordsPowerSync(powersyncDb);
```

#### SQLite (`sqlite3` package)
```dart
import 'package:sql_records/sqlite.dart';
final db = SqlRecordsSqlite(sqlite3Database);
```

#### PostgreSQL
```dart
import 'package:sql_records/postgres.dart';
final db = SqlRecordsPostgres(postgresSession);
```

### 3. Executing Queries
The `SqlRecords` interface provides methods for executing queries and mutations.

#### `getAll`, `get`, `getOptional`
Returns `RowSet<R>` or `Row<R>`. Parameters are optional for `Query<void, R>`.

```dart
// With parameters
final rows = await db.getAll(activeUsersQuery, (status: 'active'));

// Without parameters (.static)
final allRows = await db.getAll(allUsersQuery);

for (final row in rows) {
  final name = row.get<String>('name');
}
```

### 4. Executing Mutations
Mutations use the `Command<P>` class.

#### `execute`
Executes a command and returns a `MutationResult`. Parameters are optional for `Command<void>`.

```dart
// With parameters
final result = await db.execute(updateUserCommand, (id: '123', name: 'New Name'));

// Without parameters (.static)
await db.execute(deleteAllCommand);

print('Rows affected: ${result.affectedRows}');
```

#### `executeBatch`
Efficiently executes a command multiple times in a single batch operation.

```dart
await db.executeBatch(insertUserCommand, [
  (id: '1', name: 'User 1'),
  (id: '2', name: 'User 2'),
]);
```

### 5. Reactive Queries
Reactive queries are supported via `watch`.

```dart
final stream = db.watch(activeUsersQuery, params: (status: 'active'));
await for (final resultSet in stream) {
  // resultSet is RowSet<R>
}
```

### 6. Transactions
Transactions provide a scope for multiple operations.

- `readTransaction`: Provides a read-only context (`SqlRecordsReadonly`).
- `writeTransaction`: Provides a read-write context (`SqlRecords`).

```dart
final result = await db.writeTransaction((tx) async {
  await tx.execute(updateUserCommand, (id: '123', name: 'New Name'));
  return tx.get(userQuery, (id: '123'));
});
```

### 7. Row & Data Parsing
`Row` wraps the raw database row and enforces the schema.

- `row.get<T>(key)`: Type-safe, non-nullable access.
- `row.getOptional<T>(key)`: Type-safe, nullable access.
- `row.parse<T, DB>(key, parser)`: Custom parsing logic.

#### Common Parsers (`RowConvenience`)
- `row.parseEnumByName<T extends Enum>(key, values)`: Parses a string into an enum.
- `row.parseDateTime(key)`: Parses an ISO-8601 string or epoch integer into a `DateTime`.
- `row.parseEnumByNameOptional<T extends Enum>(key, values)`: Nullable version of enum parsing.
- `row.parseDateTimeOptional(key)`: Nullable version of DateTime parsing.

## Caveats & Troubleshooting
- **Named Parameters**: Use the `@name` syntax for SQLite and PostgreSQL.
- **Postgres ID**: `MutationResult.lastInsertId` is always `null` for Postgres unless using `RETURNING` clauses in the query.
- **Watch**: `watch()` is currently only supported for PowerSync.
- **Type Safety**: Parameters (`P`) must be Dart Records or `void`. Result sets (`R`) must be Dart Records.
